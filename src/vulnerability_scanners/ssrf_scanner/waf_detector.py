from enum import Enum
from dataclasses import dataclass
from typing import List, Dict, Optional, Set
import re

class WAFType(Enum):
    """WAF türleri"""
    CLOUDFLARE = "Cloudflare"
    AKAMAI = "Akamai"
    IMPERVA = "Imperva"
    F5_ASM = "F5 ASM"
    MODSECURITY = "ModSecurity"
    FORTIWEB = "FortiWeb"
    UNKNOWN = "Unknown"

@dataclass
class WAFDetectionResult:
    """WAF tespit sonucu"""
    detected: bool
    waf_type: WAFType
    confidence: float
    details: str

class WAFDetector:
    """WAF tespit ve bypass sınıfı"""
    
    def __init__(self):
        """WAF tespit ve bypass sınıfını başlatır"""
        # WAF imzaları
        self.waf_signatures = {
            WAFType.CLOUDFLARE: {
                "headers": ["cf-ray", "cf-cache-status", "__cfduid"],
                "response_patterns": ["cloudflare", "ray id:"],
                "block_patterns": ["challenge-form", "jschl-answer"]
            },
            WAFType.AKAMAI: {
                "headers": ["x-akamai-transformed", "akamai-origin-hop"],
                "response_patterns": ["akamai", "reference"],
                "block_patterns": ["access denied", "denied access"]
            },
            WAFType.IMPERVA: {
                "headers": ["x-iinfo", "x-cdn"],
                "response_patterns": ["imperva", "incapsula"],
                "block_patterns": ["blocked", "incapsula incident"]
            },
            WAFType.F5_ASM: {
                "headers": ["x-wa-info", "x-asm-request-id"],
                "response_patterns": ["f5 networks", "asm"],
                "block_patterns": ["the requested url was rejected", "request rejected"]
            },
            WAFType.MODSECURITY: {
                "headers": ["x-mod-security", "x-powered-by"],
                "response_patterns": ["mod_security", "modsecurity"],
                "block_patterns": ["error 403", "forbidden"]
            },
            WAFType.FORTIWEB: {
                "headers": ["x-fortigate", "x-fortiweb-result"],
                "response_patterns": ["fortinet", "fortiweb"],
                "block_patterns": ["attack detected", "waf block"]
            }
        }
        
        # WAF bypass teknikleri
        self.bypass_techniques = {
            WAFType.CLOUDFLARE: [
                self._double_url_encode,
                self._add_null_byte,
                self._add_newline,
                self._unicode_encode
            ],
            WAFType.AKAMAI: [
                self._url_encode,
                self._add_port,
                self._add_fragment,
                self._add_credentials
            ],
            WAFType.IMPERVA: [
                self._hex_encode,
                self._add_dot_slash,
                self._add_query_param,
                self._mixed_case
            ],
            WAFType.F5_ASM: [
                self._base64_encode,
                self._add_space,
                self._add_comment,
                self._add_protocol
            ],
            WAFType.MODSECURITY: [
                self._unicode_encode,
                self._add_slash,
                self._add_header,
                self._change_method
            ],
            WAFType.FORTIWEB: [
                self._url_encode,
                self._add_path,
                self._add_anchor,
                self._add_scheme
            ]
        }
        
    def detect_waf(self, headers: Dict[str, str], response_content: str) -> WAFDetectionResult:
        """
        WAF varlığını tespit eder.
        
        Args:
            headers: HTTP yanıt başlıkları
            response_content: HTTP yanıt içeriği
            
        Returns:
            WAFDetectionResult: WAF tespit sonucu
        """
        for waf_type, signatures in self.waf_signatures.items():
            confidence = 0.0
            matches = []
            
            # Header kontrolü
            for header in signatures["headers"]:
                if any(h.lower() == header.lower() for h in headers):
                    confidence += 0.3
                    matches.append(f"Header found: {header}")
                    
            # Yanıt pattern kontrolü
            for pattern in signatures["response_patterns"]:
                if re.search(pattern, response_content, re.IGNORECASE):
                    confidence += 0.3
                    matches.append(f"Response pattern found: {pattern}")
                    
            # Block pattern kontrolü
            for pattern in signatures["block_patterns"]:
                if re.search(pattern, response_content, re.IGNORECASE):
                    confidence += 0.4
                    matches.append(f"Block pattern found: {pattern}")
                    
            if confidence > 0:
                return WAFDetectionResult(
                    detected=True,
                    waf_type=waf_type,
                    confidence=min(confidence, 1.0),
                    details=", ".join(matches)
                )
                
        return WAFDetectionResult(
            detected=False,
            waf_type=WAFType.UNKNOWN,
            confidence=0.0,
            details="No WAF detected"
        )
        
    def get_bypass_payloads(self, waf_type: WAFType, original_payload: str) -> List[str]:
        """
        WAF bypass payloadları üretir.
        
        Args:
            waf_type: WAF türü
            original_payload: Orijinal payload
            
        Returns:
            List[str]: Bypass payloadları
        """
        bypass_payloads = []
        
        if waf_type in self.bypass_techniques:
            for technique in self.bypass_techniques[waf_type]:
                bypass_payload = technique(original_payload)
                if bypass_payload:
                    bypass_payloads.append(bypass_payload)
                    
        return bypass_payloads
        
    def _url_encode(self, payload: str) -> str:
        """URL encoding"""
        return "".join(f"%{ord(c):02x}" for c in payload)
        
    def _double_url_encode(self, payload: str) -> str:
        """Double URL encoding"""
        return "".join(f"%%{ord(c):02x}" for c in payload)
        
    def _hex_encode(self, payload: str) -> str:
        """Hex encoding"""
        return "0x" + "".join(f"{ord(c):02x}" for c in payload)
        
    def _base64_encode(self, payload: str) -> str:
        """Base64 encoding"""
        import base64
        return base64.b64encode(payload.encode()).decode()
        
    def _unicode_encode(self, payload: str) -> str:
        """Unicode encoding"""
        return "".join(f"\\u{ord(c):04x}" for c in payload)
        
    def _add_null_byte(self, payload: str) -> str:
        """Null byte ekleme"""
        return payload + "%00"
        
    def _add_newline(self, payload: str) -> str:
        """Newline ekleme"""
        return payload + "%0a"
        
    def _add_port(self, payload: str) -> str:
        """Port ekleme"""
        return payload.replace("://", "://:80@")
        
    def _add_fragment(self, payload: str) -> str:
        """Fragment ekleme"""
        return payload + "#"
        
    def _add_credentials(self, payload: str) -> str:
        """Credentials ekleme"""
        return payload.replace("://", "://user:pass@")
        
    def _add_dot_slash(self, payload: str) -> str:
        """Dot-slash ekleme"""
        return payload.replace("/", "/./")
        
    def _add_query_param(self, payload: str) -> str:
        """Query parametresi ekleme"""
        return payload + "?id=1"
        
    def _mixed_case(self, payload: str) -> str:
        """Mixed case"""
        return "".join(c.upper() if i % 2 else c.lower() for i, c in enumerate(payload))
        
    def _add_space(self, payload: str) -> str:
        """Space ekleme"""
        return payload.replace("/", "/ ")
        
    def _add_comment(self, payload: str) -> str:
        """Comment ekleme"""
        return payload + "<!-->"
        
    def _add_protocol(self, payload: str) -> str:
        """Protokol ekleme"""
        return "http://" + payload
        
    def _add_slash(self, payload: str) -> str:
        """Slash ekleme"""
        return payload + "/"
        
    def _add_header(self, payload: str) -> str:
        """Header ekleme"""
        return payload + "\r\nX-Forwarded-For: 127.0.0.1"
        
    def _change_method(self, payload: str) -> str:
        """HTTP metodu değiştirme"""
        return "POST " + payload
        
    def _add_path(self, payload: str) -> str:
        """Path ekleme"""
        return payload + "/path"
        
    def _add_anchor(self, payload: str) -> str:
        """Anchor ekleme"""
        return payload + "#anchor"
        
    def _add_scheme(self, payload: str) -> str:
        """Scheme ekleme"""
        return "https://" + payload 