"""
SSRF Scanner ana modülü
"""
import logging
import asyncio
import ipaddress
from typing import List, Dict, Optional, Set
from dataclasses import dataclass
import aiohttp
from bs4 import BeautifulSoup
from .payloads import SSRFPayload, SSRFType, Protocol, PayloadGenerator
from enum import Enum
import requests
import socket
import dns.resolver
from urllib.parse import urlparse
from .waf_detector import WAFDetector, WAFDetectionResult, WAFType
from .html_reporter import HTMLReporter

class SSRFType(Enum):
    """SSRF zafiyet türleri"""
    BASIC = "Basic SSRF"
    BLIND = "Blind SSRF"
    OPEN_REDIRECT = "Open Redirect"
    FILE_READ = "File Read"
    
class Protocol(Enum):
    """Desteklenen protokoller"""
    HTTP = "http"
    HTTPS = "https"
    FTP = "ftp"
    SFTP = "sftp"
    FILE = "file"
    DICT = "dict"
    GOPHER = "gopher"
    LDAP = "ldap"
    TFTP = "tftp"
    SMB = "smb"
    REDIS = "redis"
    MONGODB = "mongodb"
    POSTGRES = "postgres"
    MYSQL = "mysql"
    TELNET = "telnet"
    SSH = "ssh"
    RSYNC = "rsync"
    GIT = "git"
    DOCKER = "docker"

@dataclass
class ScanResult:
    """SSRF tarama sonucu"""
    vulnerability_type: SSRFType
    url: str
    parameter: str
    payload: SSRFPayload
    protocol: Protocol
    details: str
    severity: str
    proof_of_concept: str
    internal_access: Optional[List[str]] = None
    metadata_access: Optional[List[str]] = None

class SSRFScanner:
    """SSRF tarayıcı sınıfı"""
    
    def __init__(self, target_url: str, cookies: Optional[Dict[str, str]] = None, proxy: Optional[Dict[str, str]] = None):
        """
        SSRF tarayıcısını başlatır.
        
        Args:
            target_url: Taranacak URL
            cookies: İsteğe bağlı çerezler
            proxy: İsteğe bağlı proxy ayarları (örn: {"http": "http://127.0.0.1:8080", "https": "http://127.0.0.1:8080"})
        """
        self.target_url = target_url
        self.session = requests.Session()
        if cookies:
            self.session.cookies.update(cookies)
        if proxy:
            self.session.proxies.update(proxy)
            
        self.timeout = 10
        self.protocols = set(p.value for p in Protocol)
        self.cloud_metadata_endpoints = {
            "aws": "http://169.254.169.254/latest/meta-data/",
            "gcp": "http://metadata.google.internal/computeMetadata/v1/",
            "azure": "http://169.254.169.254/metadata/instance",
            "digitalocean": "http://169.254.169.254/metadata/v1.json",
            "alibaba": "http://100.100.100.200/latest/meta-data/"
        }
        self.waf_detector = WAFDetector()
        
    def _make_request(self, url: str, method: str = "GET", params: Optional[Dict[str, str]] = None, 
                     data: Optional[Dict[str, str]] = None, headers: Optional[Dict[str, str]] = None,
                     allow_redirects: bool = False) -> Optional[requests.Response]:
        """HTTP isteği gönderir"""
        try:
            response = self.session.request(
                method=method,
                url=url,
                params=params,
                data=data,
                headers=headers,
                timeout=self.timeout,
                allow_redirects=allow_redirects,
                verify=False
            )
            response.raise_for_status()
            return response
        except requests.exceptions.RequestException:
            return None
            
    def _check_dns_resolution(self, hostname: str) -> bool:
        """DNS çözümlemesi yapar"""
        try:
            dns.resolver.resolve(hostname, "A")
            return True
        except dns.exception.DNSException:
            return False
            
    def _check_port(self, host: str, port: int) -> bool:
        """Port kontrolü yapar"""
        try:
            with socket.create_connection((host, port), timeout=self.timeout):
                return True
        except (socket.timeout, socket.error):
            return False
            
    def _check_protocol(self, url: str, protocol: Protocol) -> bool:
        """Protokol desteğini kontrol eder"""
        parsed = urlparse(url)
        if protocol == Protocol.HTTP:
            return self._check_port(parsed.hostname, 80)
        elif protocol == Protocol.HTTPS:
            return self._check_port(parsed.hostname, 443)
        elif protocol == Protocol.FTP:
            return self._check_port(parsed.hostname, 21)
        elif protocol == Protocol.SFTP:
            return self._check_port(parsed.hostname, 22)
        elif protocol == Protocol.DICT:
            return self._check_port(parsed.hostname, 2628)
        elif protocol == Protocol.GOPHER:
            return self._check_port(parsed.hostname, 70)
        elif protocol == Protocol.LDAP:
            return self._check_port(parsed.hostname, 389)
        elif protocol == Protocol.TFTP:
            return self._check_port(parsed.hostname, 69)
        elif protocol == Protocol.SMB:
            return self._check_port(parsed.hostname, 445)
        elif protocol == Protocol.REDIS:
            return self._check_port(parsed.hostname, 6379)
        elif protocol == Protocol.MONGODB:
            return self._check_port(parsed.hostname, 27017)
        elif protocol == Protocol.POSTGRES:
            return self._check_port(parsed.hostname, 5432)
        elif protocol == Protocol.MYSQL:
            return self._check_port(parsed.hostname, 3306)
        elif protocol == Protocol.TELNET:
            return self._check_port(parsed.hostname, 23)
        elif protocol == Protocol.SSH:
            return self._check_port(parsed.hostname, 22)
        elif protocol == Protocol.RSYNC:
            return self._check_port(parsed.hostname, 873)
        elif protocol == Protocol.GIT:
            return self._check_port(parsed.hostname, 9418)
        elif protocol == Protocol.DOCKER:
            return self._check_port(parsed.hostname, 2375)
        return False
            
    def scan_parameter(self, parameter: str, value: str) -> List[ScanResult]:
        """
        Belirtilen parametreyi SSRF açıkları için tarar.
        
        Args:
            parameter: Taranacak parametre
            value: Parametre değeri
            
        Returns:
            List[ScanResult]: Tespit edilen SSRF açıklarının listesi
        """
        results = []
        
        # WAF tespiti yap
        response = self._make_request(self.target_url)
        if response:
            waf_result = self.waf_detector.detect_waf(
                dict(response.headers),
                response.text
            )
            if waf_result.detected:
                print(f"WAF tespit edildi: {waf_result.waf_type.value} ({waf_result.confidence:.2f})")
        
        # Temel SSRF testleri
        for payload in PayloadGenerator.get_basic_payloads():
            test_value = value + payload.value
            
            # WAF bypass dene
            if waf_result and waf_result.detected:
                bypass_payloads = self.waf_detector.get_bypass_payloads(
                    waf_result.waf_type,
                    test_value
                )
                for bypass_payload in bypass_payloads:
                    for protocol in Protocol:
                        if self._check_protocol(bypass_payload, protocol):
                            results.append(
                                ScanResult(
                                    vulnerability_type=SSRFType.BASIC,
                                    url=self.target_url,
                                    parameter=parameter,
                                    payload=payload,
                                    protocol=protocol,
                                    details=f"Temel SSRF açığı tespit edildi ({protocol.value} protokolü, WAF bypass)",
                                    severity="Kritik",
                                    proof_of_concept=f"Parametre: {parameter}, Payload: {bypass_payload}, Protokol: {protocol.value}"
                                )
                            )
            else:
                for protocol in Protocol:
                    if self._check_protocol(test_value, protocol):
                        results.append(
                            ScanResult(
                                vulnerability_type=SSRFType.BASIC,
                                url=self.target_url,
                                parameter=parameter,
                                payload=payload,
                                protocol=protocol,
                                details=f"Temel SSRF açığı tespit edildi ({protocol.value} protokolü)",
                                severity="Yüksek",
                                proof_of_concept=f"Parametre: {parameter}, Payload: {test_value}, Protokol: {protocol.value}"
                            )
                        )
                    
        # Blind SSRF testleri
        for payload in PayloadGenerator.get_blind_payloads():
            test_value = value + payload.value
            if self._check_dns_resolution(urlparse(test_value).hostname):
                results.append(
                    ScanResult(
                        vulnerability_type=SSRFType.BLIND,
                        url=self.target_url,
                        parameter=parameter,
                        payload=payload,
                        protocol=Protocol.HTTP,
                        details="Blind SSRF açığı tespit edildi (DNS çözümlemesi başarılı)",
                        severity="Orta",
                        proof_of_concept=f"Parametre: {parameter}, Payload: {test_value}"
                    )
                )
                
        # Cloud metadata testleri
        for cloud, endpoint in self.cloud_metadata_endpoints.items():
            for payload in PayloadGenerator.get_cloud_metadata_payloads():
                test_value = value + payload.value.replace("ENDPOINT", endpoint)
                response = self._make_request(
                    self.target_url,
                    params={parameter: test_value}
                )
                if response and any(indicator in response.text for indicator in payload.success_indicators):
                    results.append(
                        ScanResult(
                            vulnerability_type=SSRFType.CLOUD_METADATA,
                            url=self.target_url,
                            parameter=parameter,
                            payload=payload,
                            protocol=Protocol.HTTP,
                            details=f"Cloud metadata erişimi tespit edildi ({cloud})",
                            severity="Kritik",
                            proof_of_concept=f"Parametre: {parameter}, Payload: {test_value}, Platform: {cloud}"
                        )
                    )
                    
        # İç ağ keşif testleri
        for payload in PayloadGenerator.get_internal_network_payloads():
            test_value = value + payload.value
            response = self._make_request(
                self.target_url,
                params={parameter: test_value}
            )
            if response and any(indicator in response.text for indicator in payload.success_indicators):
                results.append(
                    ScanResult(
                        vulnerability_type=SSRFType.INTERNAL_NETWORK,
                        url=self.target_url,
                        parameter=parameter,
                        payload=payload,
                        protocol=Protocol.HTTP,
                        details="İç ağ erişimi tespit edildi",
                        severity="Yüksek",
                        proof_of_concept=f"Parametre: {parameter}, Payload: {test_value}"
                    )
                )
                
        return results
    
    def _generate_internal_ips(self) -> List[str]:
        """Test edilecek iç ağ IP'lerini üret"""
        ips = []
        networks = [
            "127.0.0.0/8",      # Localhost
            "192.168.0.0/16",   # Özel ağ
            "10.0.0.0/8",       # Özel ağ
            "172.16.0.0/12"     # Özel ağ
        ]
        
        for network in networks:
            try:
                # Her ağdan ilk 10 IP'yi al
                for ip in list(ipaddress.ip_network(network).hosts())[:10]:
                    ips.append(str(ip))
            except Exception as e:
                self.logger.error(f"IP üretimi sırasında hata: {str(e)}")
                
        return ips 

    def scan(self, output_format: str = "json", output_file: Optional[str] = None) -> List[ScanResult]:
        """
        SSRF taraması yapar ve sonuçları döndürür.
        
        Args:
            output_format: Çıktı formatı ("json" veya "html")
            output_file: Çıktının kaydedileceği dosya yolu
            
        Returns:
            Tarama sonuçları listesi
        """
        results = []
        
        # Basic SSRF testi
        basic_results = self._test_basic_ssrf()
        results.extend(basic_results)
        
        # Blind SSRF testi
        blind_results = self._test_blind_ssrf()
        results.extend(blind_results)
        
        # Open Redirect testi
        redirect_results = self._test_open_redirect()
        results.extend(redirect_results)
        
        # File Read testi
        file_results = self._test_file_read()
        results.extend(file_results)
        
        # Sonuçları kaydet
        if output_file:
            self._save_results(results, output_format, output_file)
            
        return results
        
    def _save_results(self, results: List[ScanResult], output_format: str, output_file: str) -> None:
        """Sonuçları belirtilen formatta kaydeder"""
        if output_format == "html":
            reporter = HTMLReporter()
            reporter.generate_report(results, self.target_url, output_file)
        else:
            # JSON formatında kaydet
            import json
            
            json_results = []
            for result in results:
                json_results.append({
                    "vulnerability_type": result.vulnerability_type.value,
                    "url": result.url,
                    "protocol": result.protocol.value,
                    "severity": result.severity,
                    "details": result.details,
                    "proof_of_concept": result.proof_of_concept
                })
                
            with open(output_file, "w", encoding="utf-8") as f:
                json.dump(json_results, f, indent=4, ensure_ascii=False)
                
    def _test_basic_ssrf(self) -> List[ScanResult]:
        """Basic SSRF testleri yapar"""
        results = []
        # Test implementasyonu
        return results
        
    def _test_blind_ssrf(self) -> List[ScanResult]:
        """Blind SSRF testleri yapar"""
        results = []
        # Test implementasyonu
        return results
        
    def _test_open_redirect(self) -> List[ScanResult]:
        """Open Redirect testleri yapar"""
        results = []
        # Test implementasyonu
        return results
        
    def _test_file_read(self) -> List[ScanResult]:
        """File Read testleri yapar"""
        results = []
        # Test implementasyonu
        return results 