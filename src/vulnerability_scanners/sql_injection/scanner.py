"""
SQL Injection Scanner ana modülü.
Bu modül, SQL injection zafiyetlerini tespit eder.
"""

import asyncio
import logging
import aiohttp
import time
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from .payload_generator import PayloadGenerator, PayloadType, Payload
from .waf_detector import WAFDetector, WAFBypass, WAFType, WAFDetectionResult
from bs4 import BeautifulSoup

# Loglama yapılandırması
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@dataclass
class ScanResult:
    """Tarama sonucu veri sınıfı."""
    vulnerability_type: str
    url: str
    parameter: str
    payload: str
    details: str
    severity: str
    waf_detected: Optional[WAFDetectionResult] = None
    bypass_payload: Optional[str] = None

class SQLInjectionScanner:
    """SQL Injection tarayıcı sınıfı."""
    
    def __init__(self, target_url: str, cookies: Optional[Dict] = None, proxy: Optional[str] = None):
        self.target_url = target_url
        self.cookies = cookies or {}
        self.proxy = proxy
        self.logger = logging.getLogger(__name__)
        self.results: List[ScanResult] = []
        self.waf_detector = WAFDetector()
        self.payloads = PayloadGenerator()
        self.detected_waf = None
    
    async def __aenter__(self):
        """Context manager giriş metodu."""
        self.session = aiohttp.ClientSession(
            cookies=self.cookies,
            trust_env=True  # Sistem proxy ayarlarını kullan
        )
        if self.proxy:
            self.session._connector._ssl = False  # SSL doğrulamasını devre dışı bırak
            self.session._connector_owner = False
            self.session._connector = aiohttp.TCPConnector(ssl=False)
            self.session._connector._remote_resolve = False
        
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Context manager çıkış metodu."""
        await self.session.close()
    
    async def _make_request(self, url: str, params: Dict = None) -> Tuple[int, str, Dict]:
        """HTTP isteği gönder"""
        try:
            proxy_settings = {
                'http': self.proxy,
                'https': self.proxy
            } if self.proxy else None
            
            async with self.session.get(url, params=params, proxy=proxy_settings) as response:
                return (
                    response.status,
                    await response.text(),
                    dict(response.headers)
                )
        except Exception as e:
            self.logger.error(f"İstek hatası: {str(e)}")
            return (0, str(e), {})
    
    async def detect_waf(self) -> Tuple[bool, Optional[WAFDetectionResult]]:
        """
        WAF varlığını tespit eder.
        
        Returns:
            WAF tespit sonucu ve bypass gerekip gerekmediği
        """
        try:
            # Test isteği gönder
            params = {self.target_url: "1' OR '1'='1"}
            status, response_text, headers = await self._make_request(self.target_url, params)
            
            # WAF tespiti yap
            waf_result = self.waf_detector.detect_waf(headers, response_text)
            
            if waf_result.detected:
                logger.info(f"WAF tespit edildi: {waf_result.waf_type.value} ({waf_result.confidence:.2f})")
                logger.debug(f"WAF tespit detayları:\n{waf_result.details}")
                return True, waf_result
            
            return False, None
            
        except Exception as e:
            logger.error(f"WAF tespiti sırasında hata: {e}")
            return False, None
    
    async def test_blind_injection(self, payload: Payload, bypass_payload: Optional[str] = None) -> Optional[ScanResult]:
        """
        Blind SQL injection testi yapar.
        
        Args:
            payload: Test edilecek payload
            bypass_payload: WAF bypass payload'ı
            
        Returns:
            Zafiyet varsa ScanResult nesnesi, yoksa None
        """
        try:
            # Payload'ı hazırla
            test_payload = bypass_payload if bypass_payload else payload.value
            
            # İlk istek - true condition
            status, true_response, _ = await self._make_request(self.target_url, {self.target_url: test_payload})
            true_time = time.time()
            
            # İkinci istek - false condition
            false_condition = test_payload.replace("1=1", "1=2")
            status, false_response, _ = await self._make_request(self.target_url, {self.target_url: false_condition})
            false_time = time.time()
            
            # Boolean-based blind analizi
            if status != false_status:
                return ScanResult(
                    vulnerability_type="Blind SQL Injection (Boolean-based)",
                    url=self.target_url,
                    parameter=self.target_url,
                    payload=test_payload,
                    details=f"Farklı HTTP durum kodları: {status} vs {false_status}",
                    severity="High",
                    waf_detected=self.detected_waf,
                    bypass_payload=bypass_payload
                )
            
            # Error-based blind analizi
            if "error" in false_response.lower() and "error" not in true_response.lower():
                return ScanResult(
                    vulnerability_type="Blind SQL Injection (Error-based)",
                    url=self.target_url,
                    parameter=self.target_url,
                    payload=test_payload,
                    details="Hata mesajı farklılığı tespit edildi",
                    severity="High",
                    waf_detected=self.detected_waf,
                    bypass_payload=bypass_payload
                )
            
            # Time-based blind analizi
            time_difference = abs(true_time - false_time)
            if time_difference >= 5:  # 5 saniye gecikme eşiği
                return ScanResult(
                    vulnerability_type="Blind SQL Injection (Time-based)",
                    url=self.target_url,
                    parameter=self.target_url,
                    payload=test_payload,
                    details=f"Zaman farkı: {time_difference:.2f} saniye",
                    severity="High",
                    waf_detected=self.detected_waf,
                    bypass_payload=bypass_payload
                )
            
            # İçerik uzunluğu analizi
            content_diff = abs(len(true_response) - len(false_response))
            if content_diff > 100:  # 100 karakter fark eşiği
                return ScanResult(
                    vulnerability_type="Blind SQL Injection (Content-based)",
                    url=self.target_url,
                    parameter=self.target_url,
                    payload=test_payload,
                    details=f"İçerik uzunluğu farkı: {content_diff} karakter",
                    severity="High",
                    waf_detected=self.detected_waf,
                    bypass_payload=bypass_payload
                )
            
            return None
            
        except Exception as e:
            logger.error(f"Blind SQL injection testi sırasında hata: {e}")
            return None
    
    async def scan_parameter(self) -> List[ScanResult]:
        """
        Parametreyi SQL injection açıklarına karşı tarar.
        
        Returns:
            Bulunan zafiyetlerin listesi
        """
        results = []
        
        try:
            # WAF tespiti yap
            has_waf, waf_result = await self.detect_waf()
            self.detected_waf = waf_result
            
            # WAF bypass payload'larını hazırla
            bypass_payloads = []
            if has_waf:
                bypass_payloads = WAFBypass.get_bypass_payloads(waf_result.waf_type)
                logger.info(f"{len(bypass_payloads)} adet WAF bypass payload'ı hazırlandı")
            
            # Blind SQL injection testleri
            for payload in self.payloads.get_blind_payloads():
                if has_waf:
                    # WAF bypass dene
                    for bypass in bypass_payloads:
                        result = await self.test_blind_injection(payload, bypass)
                        if result:
                            results.append(result)
                            logger.info(f"WAF bypass başarılı: {bypass}")
                            break
                else:
                    # Normal test
                    result = await self.test_blind_injection(payload)
                    if result:
                        results.append(result)
            
            # Boolean-based testler
            for payload in self.payloads.get_boolean_payloads():
                # Boolean-based test kodları...
                pass
            
            # Time-based testler
            for payload in self.payloads.get_time_payloads():
                # Time-based test kodları...
                pass
            
            # Error-based testler
            for payload in self.payloads.get_error_payloads():
                # Error-based test kodları...
                pass
            
            # Union-based testler
            for payload in self.payloads.get_union_payloads():
                # Union-based test kodları...
                pass
            
        except Exception as e:
            logger.error(f"Parametre taraması sırasında hata: {e}")
        
        return results
    
    async def scan_url(self) -> Dict[str, List[ScanResult]]:
        """
        URL'yi SQL injection açıklarına karşı tarar.
        
        Returns:
            Parametre bazlı zafiyet sonuçları
        """
        results = {}
        
        try:
            async with self:  # Context manager kullanımı
                results[self.target_url] = await self.scan_parameter()
        except Exception as e:
            logger.error(f"URL taraması sırasında hata: {e}")
        
        return results 