"""
XSS Scanner ana modülü
"""
import logging
import asyncio
from typing import List, Dict, Optional, Set
from dataclasses import dataclass
import aiohttp
from bs4 import BeautifulSoup
from playwright.async_api import async_playwright, Browser, Page
from .payloads import XSSPayload, PayloadGenerator, XSSType, XSSContext
from .waf_detector import WAFDetector, WAFDetectionResult, WAFType
from .encoder import XSSEncoder, EncodingType
import requests
from enum import Enum

@dataclass
class ScanResult:
    """Tarama sonucu veri sınıfı"""
    vulnerability_type: XSSType
    url: str
    parameter: str
    payload: XSSPayload
    context: XSSContext
    details: str
    severity: str
    proof_of_concept: str
    encoded_payload: Optional[str] = None
    encoding_type: Optional[EncodingType] = None

class XSSScanner:
    """XSS tarayıcı sınıfı"""
    
    def __init__(self, target_url: str, cookies: Optional[Dict[str, str]] = None, proxy: Optional[Dict[str, str]] = None):
        """
        XSS tarayıcısını başlatır.
        
        Args:
            target_url: Taranacak URL
            cookies: İsteğe bağlı çerezler
            proxy: İsteğe bağlı proxy ayarları (örn: {"http": "http://127.0.0.1:8080", "https": "http://127.0.0.1:8080"})
        """
        self.target_url = target_url
        self.session = requests.Session()
        if cookies:
            self.session.cookies.update(cookies)
        if proxy:
            self.session.proxies.update(proxy)
            
        self.logger = logging.getLogger(__name__)
        self.results: List[ScanResult] = []
        self.timeout = 30  # saniye
        self.stored_xss_endpoints: Set[str] = set()  # Stored XSS için kontrol edilecek endpoint'ler
        self.waf_detection_result: Optional[WAFDetectionResult] = None
        self.encoder = XSSEncoder()
        
    def _make_request(self, url: str, method: str = "GET", params: Optional[Dict[str, str]] = None, 
                     data: Optional[Dict[str, str]] = None, headers: Optional[Dict[str, str]] = None) -> requests.Response:
        """
        HTTP isteği gönderir.
        
        Args:
            url: İstek URL'i
            method: HTTP metodu
            params: URL parametreleri
            data: POST verileri
            headers: HTTP başlıkları
            
        Returns:
            requests.Response: HTTP yanıtı
        """
        try:
            response = self.session.request(
                method=method,
                url=url,
                params=params,
                data=data,
                headers=headers,
                timeout=10,
                verify=False  # SSL doğrulamasını devre dışı bırak
            )
            response.raise_for_status()
            return response
        except requests.exceptions.RequestException as e:
            self.logger.error(f"İstek hatası: {str(e)}")
            return None

    async def scan_parameter(self, parameter: str, value: str, check_stored: bool = False) -> List[ScanResult]:
        """
        Belirtilen parametreyi XSS açıkları için tarar.
        
        Args:
            parameter: Taranacak parametre
            value: Parametre değeri
            check_stored: Stored XSS kontrolü yapılsın mı
            
        Returns:
            List[ScanResult]: Tespit edilen XSS açıklarının listesi
        """
        results = []
        
        # WAF tespiti yap
        self.waf_detection_result = await self._detect_waf()
        
        # Parametre bağlamını tespit et
        context = await self._detect_context(parameter, value)
        
        # Bağlama göre testleri çalıştır
        if context == XSSContext.HTML:
            results.extend(await self._test_html_context(parameter, value))
        elif context == XSSContext.ATTRIBUTE:
            results.extend(await self._test_attribute_context(parameter, value))
        elif context == XSSContext.SCRIPT:
            results.extend(await self._test_script_context(parameter, value))
        elif context == XSSContext.URL:
            results.extend(await self._test_url_context(parameter, value))
        elif context == XSSContext.STYLE:
            results.extend(await self._test_style_context(parameter, value))
            
        # DOM tabanlı XSS testi
        results.extend(await self._test_dom_based(parameter, value))
        
        # Stored XSS testi
        if check_stored:
            results.extend(await self._test_stored_xss(parameter, value))
            
        return results
    
    async def _detect_context(self, parameter: str, value: str) -> XSSContext:
        """Parametre bağlamını tespit et"""
        async with aiohttp.ClientSession(cookies=self.session.cookies) as session:
            try:
                async with session.get(
                    self.target_url,
                    params={parameter: value},
                    timeout=self.timeout
                ) as response:
                    content = await response.text()
                    soup = BeautifulSoup(content, 'html.parser')
                    
                    # Value'nun geçtiği yerleri bul
                    for element in soup.find_all(string=value):
                        parent = element.parent
                        
                        # Script içinde mi?
                        if parent.name == 'script':
                            return XSSContext.SCRIPT
                        
                        # Style içinde mi?
                        elif parent.name == 'style':
                            return XSSContext.STYLE
                        
                        # URL içinde mi?
                        elif parent.name == 'a' and 'href' in parent.attrs:
                            return XSSContext.URL
                        
                        # Öznitelik içinde mi?
                        elif any(value in attr for attr in parent.attrs.values()):
                            return XSSContext.ATTRIBUTE
                            
                    # Hiçbiri değilse HTML bağlamı
                    return XSSContext.HTML
                    
            except Exception as e:
                self.logger.error(f"Bağlam tespiti sırasında hata: {str(e)}")
                return XSSContext.HTML
    
    async def _detect_waf(self) -> WAFDetectionResult:
        """WAF tespiti yap"""
        try:
            async with aiohttp.ClientSession(cookies=self.session.cookies) as session:
                async with session.get(self.target_url, timeout=self.timeout) as response:
                    content = await response.text()
                    return WAFDetector.detect_waf(dict(response.headers), content)
        except Exception as e:
            self.logger.error(f"WAF tespiti sırasında hata: {str(e)}")
            return WAFDetectionResult(
                detected=False,
                waf_type=WAFType.UNKNOWN,
                confidence=0.0,
                details=f"WAF tespiti sırasında hata: {str(e)}"
            )

    async def _test_with_waf_bypass(self, parameter: str, value: str, payload: XSSPayload) -> Optional[ScanResult]:
        """WAF bypass ile test yap"""
        if not self.waf_detection_result or not self.waf_detection_result.detected:
            return None
            
        bypass_payloads = WAFDetector.get_bypass_payloads(
            self.waf_detection_result.waf_type,
            payload.value
        )
        
        for bypass_payload in bypass_payloads:
            try:
                test_value = value + bypass_payload
                async with aiohttp.ClientSession(cookies=self.session.cookies) as session:
                    async with session.get(
                        self.target_url,
                        params={parameter: test_value},
                        timeout=self.timeout
                    ) as response:
                        content = await response.text()
                        
                        if payload.success_indicators and \
                           any(indicator in content for indicator in payload.success_indicators):
                            return ScanResult(
                                vulnerability_type=payload.xss_type,
                                url=str(response.url),
                                parameter=parameter,
                                payload=payload,
                                context=payload.context,
                                details=f"XSS açığı tespit edildi (WAF Bypass). WAF Türü: {self.waf_detection_result.waf_type.value}",
                                severity="Kritik",
                                proof_of_concept=f"Parametre: {parameter}, Payload: {bypass_payload}, WAF: {self.waf_detection_result.waf_type.value}"
                            )
            except Exception as e:
                self.logger.error(f"WAF bypass testi sırasında hata: {str(e)}")
                
        return None

    async def _test_html_context(self, parameter: str, value: str) -> List[ScanResult]:
        """HTML bağlamı için XSS testi"""
        results = []
        payloads = PayloadGenerator.get_html_payloads()
        
        for payload in payloads:
            try:
                # Normal test
                test_value = value + payload.value
                async with aiohttp.ClientSession(cookies=self.session.cookies) as session:
                    async with session.get(
                        self.target_url,
                        params={parameter: test_value},
                        timeout=self.timeout
                    ) as response:
                        content = await response.text()
                        
                        if payload.success_indicators and \
                           any(indicator in content for indicator in payload.success_indicators):
                            results.append(
                                ScanResult(
                                    vulnerability_type=payload.xss_type,
                                    url=str(response.url),
                                    parameter=parameter,
                                    payload=payload,
                                    context=XSSContext.HTML_TAG,
                                    details="HTML bağlamında XSS açığı tespit edildi",
                                    severity="Yüksek",
                                    proof_of_concept=f"Parametre: {parameter}, Payload: {payload.value}"
                                )
                            )
                        # WAF tespit edildi ve normal test başarısız olduysa bypass dene
                        elif self.waf_detection_result and self.waf_detection_result.detected:
                            bypass_result = await self._test_with_waf_bypass(parameter, value, payload)
                            if bypass_result:
                                results.append(bypass_result)
                                
            except Exception as e:
                self.logger.error(f"HTML test sırasında hata: {str(e)}")
                
        return results
    
    async def _test_attribute_context(self, parameter: str, value: str) -> List[ScanResult]:
        """Öznitelik bağlamı için XSS testi"""
        results = []
        payloads = PayloadGenerator.get_attribute_context_payloads()
        
        async with aiohttp.ClientSession(cookies=self.session.cookies) as session:
            for payload in payloads:
                try:
                    test_value = value + payload.value
                    async with session.get(
                        self.target_url,
                        params={parameter: test_value},
                        timeout=self.timeout
                    ) as response:
                        content = await response.text()
                        
                        if payload.success_indicators and \
                           any(indicator in content for indicator in payload.success_indicators):
                            results.append(
                                ScanResult(
                                    vulnerability_type=XSSType.REFLECTED,
                                    url=str(response.url),
                                    parameter=parameter,
                                    payload=payload,
                                    context=XSSContext.ATTRIBUTE,
                                    details="Öznitelik bağlamında XSS açığı tespit edildi",
                                    severity="Yüksek",
                                    proof_of_concept=f"Parametre: {parameter}, Payload: {payload.value}"
                                )
                            )
                except Exception as e:
                    self.logger.error(f"Öznitelik testi sırasında hata: {str(e)}")
                    
        return results
    
    async def _test_script_context(self, parameter: str, value: str) -> List[ScanResult]:
        """Script bağlamı için XSS testi"""
        results = []
        payloads = PayloadGenerator.get_script_context_payloads()
        
        async with aiohttp.ClientSession(cookies=self.session.cookies) as session:
            for payload in payloads:
                try:
                    test_value = value + payload.value
                    async with session.get(
                        self.target_url,
                        params={parameter: test_value},
                        timeout=self.timeout
                    ) as response:
                        content = await response.text()
                        
                        if payload.success_indicators and \
                           any(indicator in content for indicator in payload.success_indicators):
                            results.append(
                                ScanResult(
                                    vulnerability_type=XSSType.REFLECTED,
                                    url=str(response.url),
                                    parameter=parameter,
                                    payload=payload,
                                    context=XSSContext.SCRIPT,
                                    details="Script bağlamında XSS açığı tespit edildi",
                                    severity="Kritik",
                                    proof_of_concept=f"Parametre: {parameter}, Payload: {payload.value}"
                                )
                            )
                except Exception as e:
                    self.logger.error(f"Script testi sırasında hata: {str(e)}")
                    
        return results
    
    async def _test_url_context(self, parameter: str, value: str) -> List[ScanResult]:
        """URL bağlamı için XSS testi"""
        results = []
        payloads = PayloadGenerator.get_url_context_payloads()
        
        async with aiohttp.ClientSession(cookies=self.session.cookies) as session:
            for payload in payloads:
                try:
                    test_value = value + payload.value
                    async with session.get(
                        self.target_url,
                        params={parameter: test_value},
                        timeout=self.timeout
                    ) as response:
                        content = await response.text()
                        
                        if payload.success_indicators and \
                           any(indicator in content for indicator in payload.success_indicators):
                            results.append(
                                ScanResult(
                                    vulnerability_type=XSSType.REFLECTED,
                                    url=str(response.url),
                                    parameter=parameter,
                                    payload=payload,
                                    context=XSSContext.URL,
                                    details="URL bağlamında XSS açığı tespit edildi",
                                    severity="Yüksek",
                                    proof_of_concept=f"Parametre: {parameter}, Payload: {payload.value}"
                                )
                            )
                except Exception as e:
                    self.logger.error(f"URL testi sırasında hata: {str(e)}")
                    
        return results
    
    async def _test_style_context(self, parameter: str, value: str) -> List[ScanResult]:
        """Style bağlamı için XSS testi"""
        results = []
        payloads = PayloadGenerator.get_style_context_payloads()
        
        async with aiohttp.ClientSession(cookies=self.session.cookies) as session:
            for payload in payloads:
                try:
                    test_value = value + payload.value
                    async with session.get(
                        self.target_url,
                        params={parameter: test_value},
                        timeout=self.timeout
                    ) as response:
                        content = await response.text()
                        
                        if payload.success_indicators and \
                           any(indicator in content for indicator in payload.success_indicators):
                            results.append(
                                ScanResult(
                                    vulnerability_type=XSSType.REFLECTED,
                                    url=str(response.url),
                                    parameter=parameter,
                                    payload=payload,
                                    context=XSSContext.STYLE,
                                    details="Style bağlamında XSS açığı tespit edildi",
                                    severity="Orta",
                                    proof_of_concept=f"Parametre: {parameter}, Payload: {payload.value}"
                                )
                            )
                except Exception as e:
                    self.logger.error(f"Style testi sırasında hata: {str(e)}")
                    
        return results
    
    async def _test_dom_based(self, parameter: str, value: str) -> List[ScanResult]:
        """DOM tabanlı XSS testi"""
        results = []
        payloads = PayloadGenerator.get_dom_payloads()
        
        async with async_playwright() as p:
            browser = await p.chromium.launch()
            page = await browser.new_page()
            
            for payload in payloads:
                try:
                    test_value = value + payload.value
                    url = f"{self.target_url}?{parameter}={test_value}"
                    
                    # Sayfayı yükle ve JavaScript çalıştır
                    await page.goto(url, timeout=self.timeout * 1000)
                    
                    # Alert dialog'unu yakala
                    dialog_appeared = False
                    page.on("dialog", lambda dialog: dialog_appeared := True)
                    
                    # JavaScript çalıştığını kontrol et
                    if dialog_appeared or \
                       any(await page.evaluate(f"document.documentElement.innerHTML.includes('{indicator}')")
                           for indicator in (payload.success_indicators or [])):
                        results.append(
                            ScanResult(
                                vulnerability_type=XSSType.DOM,
                                url=url,
                                parameter=parameter,
                                payload=payload,
                                context=payload.context,
                                details="DOM tabanlı XSS açığı tespit edildi",
                                severity="Kritik",
                                proof_of_concept=f"Parametre: {parameter}, Payload: {payload.value}"
                            )
                        )
                except Exception as e:
                    self.logger.error(f"DOM testi sırasında hata: {str(e)}")
            
            await browser.close()
            
        return results

    async def add_stored_xss_endpoint(self, endpoint: str) -> None:
        """Stored XSS için kontrol edilecek endpoint ekle"""
        self.stored_xss_endpoints.add(endpoint)

    async def _test_stored_xss(self, parameter: str, value: str) -> List[ScanResult]:
        """Stored XSS testi"""
        results = []
        payloads = PayloadGenerator.get_stored_payloads()
        
        # Test web uygulamasını başlat
        async with async_playwright() as p:
            browser = await p.chromium.launch()
            page = await browser.new_page()
            
            for payload in payloads:
                try:
                    # Payload'ı gönder
                    test_value = value + payload.value
                    async with aiohttp.ClientSession(cookies=self.session.cookies) as session:
                        async with session.post(
                            self.target_url,
                            data={parameter: test_value},
                            timeout=self.timeout
                        ) as response:
                            if response.status == 200:
                                # Stored XSS endpoint'lerini kontrol et
                                for endpoint in self.stored_xss_endpoints:
                                    await page.goto(endpoint)
                                    page_content = await page.content()
                                    
                                    if payload.success_indicators and \
                                       any(indicator in page_content for indicator in payload.success_indicators):
                                        results.append(
                                            ScanResult(
                                                vulnerability_type=XSSType.STORED,
                                                url=endpoint,
                                                parameter=parameter,
                                                payload=payload,
                                                context=XSSContext.HTML_TAG,
                                                details=f"Stored XSS açığı tespit edildi. Payload {self.target_url} üzerinden gönderildi ve {endpoint} üzerinde tetiklendi.",
                                                severity="Kritik",
                                                proof_of_concept=f"Parametre: {parameter}, Payload: {payload.value}, Endpoint: {endpoint}"
                                            )
                                        )
                except Exception as e:
                    self.logger.error(f"Stored XSS testi sırasında hata: {str(e)}")
            
            await browser.close()
            
        return results 