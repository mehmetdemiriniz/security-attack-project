"""
XSS Scanner test modülü
"""
import pytest
from unittest.mock import Mock, patch
from src.vulnerability_scanners.xss_scanner.scanner import XSSScanner, XSSType, XSSContext
from src.vulnerability_scanners.xss_scanner.payloads import PayloadGenerator
from src.vulnerability_scanners.xss_scanner.waf_detector import WAFType, WAFDetectionResult
from src.vulnerability_scanners.xss_scanner.encoder import EncodingType

@pytest.fixture
def scanner():
    """Scanner fixture"""
    return XSSScanner("http://test.com")

@pytest.mark.asyncio
async def test_stored_xss_detection(scanner):
    """Stored XSS tespitini test eder"""
    # Test endpoint'lerini ekle
    await scanner.add_stored_xss_endpoint("http://test.com/profile")
    await scanner.add_stored_xss_endpoint("http://test.com/comments")
    
    # Playwright mock
    with patch("playwright.async_api.async_playwright") as mock_playwright:
        # Browser ve page mock'ları
        mock_browser = Mock()
        mock_page = Mock()
        
        # Page content'i ayarla
        mock_page.content.return_value = '<script>fetch("/xss?"+document.cookie)</script>'
        
        # Browser ve page mock'larını yapılandır
        mock_browser.new_page.return_value = mock_page
        mock_playwright.return_value.__aenter__.return_value.chromium.launch.return_value = mock_browser
        
        # aiohttp session mock
        with patch("aiohttp.ClientSession") as mock_session:
            mock_response = Mock()
            mock_response.status = 200
            mock_response.__aenter__.return_value = mock_response
            mock_session.return_value.post.return_value = mock_response
            
            # Stored XSS testi yap
            results = await scanner.scan_parameter("comment", "<script>alert(1)</script>")
            
            # Sonuçları kontrol et
            assert len(results) > 0
            assert any(r.vulnerability_type == XSSType.STORED for r in results)
            assert any("Stored XSS açığı tespit edildi" in r.details for r in results)

@pytest.mark.asyncio
async def test_stored_xss_multiple_endpoints(scanner):
    """Birden fazla endpoint'te Stored XSS tespitini test eder"""
    # Test endpoint'lerini ekle
    endpoints = [
        "http://test.com/profile",
        "http://test.com/comments",
        "http://test.com/messages"
    ]
    
    for endpoint in endpoints:
        await scanner.add_stored_xss_endpoint(endpoint)
    
    # Playwright mock
    with patch("playwright.async_api.async_playwright") as mock_playwright:
        # Browser ve page mock'ları
        mock_browser = Mock()
        mock_page = Mock()
        
        # Page content'i ayarla
        mock_page.content.return_value = '<img src=x onerror="fetch(\'/xss?cookie=\'+document.cookie)">'
        
        # Browser ve page mock'larını yapılandır
        mock_browser.new_page.return_value = mock_page
        mock_playwright.return_value.__aenter__.return_value.chromium.launch.return_value = mock_browser
        
        # aiohttp session mock
        with patch("aiohttp.ClientSession") as mock_session:
            mock_response = Mock()
            mock_response.status = 200
            mock_response.__aenter__.return_value = mock_response
            mock_session.return_value.post.return_value = mock_response
            
            # Stored XSS testi yap
            results = await scanner.scan_parameter("message", "<script>alert(1)</script>")
            
            # Sonuçları kontrol et
            assert len(results) >= len(endpoints)
            assert all(r.vulnerability_type == XSSType.STORED for r in results[:len(endpoints)])
            assert all(r.url in endpoints for r in results[:len(endpoints)])

@pytest.mark.asyncio
async def test_stored_xss_no_endpoints(scanner):
    """Endpoint olmadan Stored XSS tespitini test eder"""
    # Playwright mock
    with patch("playwright.async_api.async_playwright") as mock_playwright:
        # Browser ve page mock'ları
        mock_browser = Mock()
        mock_page = Mock()
        
        # Browser ve page mock'larını yapılandır
        mock_browser.new_page.return_value = mock_page
        mock_playwright.return_value.__aenter__.return_value.chromium.launch.return_value = mock_browser
        
        # Stored XSS testi yap
        results = await scanner.scan_parameter("comment", "<script>alert(1)</script>")
        
        # Sonuçları kontrol et
        assert not any(r.vulnerability_type == XSSType.STORED for r in results)

@pytest.mark.asyncio
async def test_waf_detection(scanner):
    """WAF tespitini test eder"""
    # aiohttp session mock
    with patch("aiohttp.ClientSession") as mock_session:
        mock_response = Mock()
        mock_response.headers = {
            "cf-ray": "123456789",
            "cf-cache-status": "DYNAMIC"
        }
        mock_response.text = Mock(return_value="cloudflare ray id: 123456789")
        mock_response.__aenter__.return_value = mock_response
        mock_session.return_value.get.return_value = mock_response
        
        # WAF tespiti yap
        waf_result = await scanner._detect_waf()
        
        # Sonuçları kontrol et
        assert waf_result.detected
        assert waf_result.waf_type == WAFType.CLOUDFLARE
        assert waf_result.confidence > 0.5
        assert "cloudflare" in waf_result.details.lower()

@pytest.mark.asyncio
async def test_waf_bypass(scanner):
    """WAF bypass'ı test eder"""
    # WAF tespiti mock'u
    scanner.waf_detection_result = WAFDetectionResult(
        detected=True,
        waf_type=WAFType.CLOUDFLARE,
        confidence=0.8,
        details="Cloudflare WAF tespit edildi"
    )
    
    # Test payload'ı
    test_payload = next(p for p in PayloadGenerator.get_html_payloads())
    
    # aiohttp session mock
    with patch("aiohttp.ClientSession") as mock_session:
        mock_response = Mock()
        mock_response.status = 200
        mock_response.url = "http://test.com"
        mock_response.text = Mock(return_value="alert(1)")
        mock_response.__aenter__.return_value = mock_response
        mock_session.return_value.get.return_value = mock_response
        
        # WAF bypass testi yap
        result = await scanner._test_with_waf_bypass("test", "value", test_payload)
        
        # Sonuçları kontrol et
        assert result is not None
        assert result.vulnerability_type == test_payload.xss_type
        assert "WAF Bypass" in result.details
        assert "Cloudflare" in result.proof_of_concept

@pytest.mark.asyncio
async def test_waf_bypass_multiple_techniques(scanner):
    """Birden fazla WAF bypass tekniğini test eder"""
    # WAF tespiti mock'u
    scanner.waf_detection_result = WAFDetectionResult(
        detected=True,
        waf_type=WAFType.CLOUDFLARE,
        confidence=0.8,
        details="Cloudflare WAF tespit edildi"
    )
    
    # Test payload'ları
    payloads = PayloadGenerator.get_html_payloads()
    
    # aiohttp session mock
    with patch("aiohttp.ClientSession") as mock_session:
        mock_response = Mock()
        mock_response.status = 200
        mock_response.url = "http://test.com"
        mock_response.text = Mock(return_value="alert(1)")
        mock_response.__aenter__.return_value = mock_response
        mock_session.return_value.get.return_value = mock_response
        
        # Her payload için WAF bypass testi yap
        results = []
        for payload in payloads:
            result = await scanner._test_with_waf_bypass("test", "value", payload)
            if result:
                results.append(result)
        
        # Sonuçları kontrol et
        assert len(results) > 0
        assert all("WAF Bypass" in r.details for r in results)
        assert all("Cloudflare" in r.proof_of_concept for r in results)

@pytest.mark.asyncio
async def test_waf_bypass_no_waf(scanner):
    """WAF olmadan bypass testini kontrol eder"""
    # WAF tespiti yok
    scanner.waf_detection_result = None
    
    # Test payload'ı
    test_payload = next(p for p in PayloadGenerator.get_html_payloads())
    
    # WAF bypass testi yap
    result = await scanner._test_with_waf_bypass("test", "value", test_payload)
    
    # Sonuçları kontrol et
    assert result is None

@pytest.mark.asyncio
async def test_encoding_detection(scanner):
    """Encoding tespitini test eder"""
    # Test payload'ları
    test_payloads = {
        EncodingType.URL: "%3Cscript%3Ealert(1)%3C%2Fscript%3E",
        EncodingType.HTML: "&lt;script&gt;alert(1)&lt;/script&gt;",
        EncodingType.BASE64: "PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==",
        EncodingType.HEX: "3c7363726970743e616c6572742831293c2f7363726970743e",
        EncodingType.UNICODE: "\\u003cscript\\u003ealert(1)\\u003c/script\\u003e",
        EncodingType.JS: "\\x3Cscript\\x3Ealert(1)\\x3C/script\\x3E"
    }
    
    for encoding_type, payload in test_payloads.items():
        detected = scanner.encoder.detect_encoding(payload)
        assert encoding_type in detected

@pytest.mark.asyncio
async def test_mixed_encoding(scanner):
    """Karışık encoding'leri test eder"""
    # Test payload'ı
    original_payload = "<script>alert(1)</script>"
    
    # Karışık encoding'leri al
    mixed_encodings = scanner.encoder.get_mixed_encodings(original_payload)
    
    # Sonuçları kontrol et
    assert len(mixed_encodings) > 0
    assert original_payload not in mixed_encodings
    assert all(p != original_payload for p in mixed_encodings)

@pytest.mark.asyncio
async def test_encoding_xss_detection(scanner):
    """Encoded XSS tespitini test eder"""
    # aiohttp session mock
    with patch("aiohttp.ClientSession") as mock_session:
        mock_response = Mock()
        mock_response.status = 200
        mock_response.url = "http://test.com"
        mock_response.text = Mock(return_value="alert(1)")
        mock_response.__aenter__.return_value = mock_response
        mock_session.return_value.get.return_value = mock_response
        
        # XSS testi yap
        results = await scanner._test_with_encoding(
            "test",
            "value",
            XSSContext.HTML_TAG
        )
        
        # Sonuçları kontrol et
        assert len(results) > 0
        assert all(r.encoded_payload is not None for r in results)
        assert all(r.encoding_type is not None for r in results)

@pytest.mark.asyncio
async def test_encoding_decoding_roundtrip(scanner):
    """Encoding/decoding döngüsünü test eder"""
    # Test payload'ı
    original_payload = "<script>alert(1)</script>"
    
    for encoding_type in EncodingType:
        # Encode et
        encoded = scanner.encoder.encode_payload(original_payload, encoding_type)
        assert encoded != original_payload
        
        # Decode et
        decoded = scanner.encoder.decode_payload(encoded, encoding_type)
        assert decoded == original_payload

@pytest.mark.asyncio
async def test_invalid_encoding(scanner):
    """Geçersiz encoding'leri test eder"""
    # Geçersiz payload'lar
    invalid_payloads = [
        "invalid base64 !!!",
        "invalid hex zzz",
        "invalid unicode \\uzzzz",
        None,
        ""
    ]
    
    for payload in invalid_payloads:
        # Her encoding türü için test et
        for encoding_type in EncodingType:
            # Decode işlemi hata vermemeli
            decoded = scanner.encoder.decode_payload(payload, encoding_type)
            assert decoded is not None
            
            if payload:
                # Encode işlemi hata vermemeli
                encoded = scanner.encoder.encode_payload(payload, encoding_type)
                assert encoded is not None 