"""
SQL Injection Scanner test modülü.
Bu modül, SQL injection tarayıcısını test eder.
"""

import pytest
import aiohttp
from unittest.mock import patch, MagicMock, Mock
from vulnerability_scanners.sql_injection.scanner import SQLInjectionScanner, ScanResult
from vulnerability_scanners.sql_injection.payload_generator import PayloadGenerator, PayloadType

# Test verileri
TEST_URL = "http://test.example.com/vuln"
TEST_PARAMETER = "id"
TEST_VALUE = "1"

@pytest.fixture
def scanner():
    """Scanner fixture."""
    return SQLInjectionScanner(TEST_URL, TEST_PARAMETER, TEST_VALUE)

@pytest.fixture
def mock_response():
    """Mock HTTP response fixture."""
    response = MagicMock()
    response.status = 200
    response.text = MagicMock(return_value="test response")
    return response

@pytest.mark.asyncio
async def test_blind_boolean_injection(scanner, mock_response):
    """Boolean-based blind SQL injection testini test eder."""
    # Mock response ayarları
    mock_response.status = 200
    mock_true_response = "Welcome admin"
    mock_false_response = "Invalid login"
    
    with patch('aiohttp.ClientSession') as mock_session:
        mock_session.return_value.__aenter__.return_value.get.return_value.__aenter__.side_effect = [
            MagicMock(status=200, text=MagicMock(return_value=mock_true_response)),
            MagicMock(status=403, text=MagicMock(return_value=mock_false_response))
        ]
        
        # Test payload'ı
        payload = next(p for p in PayloadGenerator.get_blind_payloads() if "1=1" in p.value)
        
        # Testi çalıştır
        result = await scanner.test_blind_injection(payload)
        
        # Sonuçları kontrol et
        assert result is not None
        assert result.vulnerability_type == "Blind SQL Injection (Boolean-based)"
        assert result.url == TEST_URL
        assert result.parameter == TEST_PARAMETER
        assert result.severity == "High"

@pytest.mark.asyncio
async def test_blind_error_injection(scanner, mock_response):
    """Error-based blind SQL injection testini test eder."""
    # Mock response ayarları
    mock_true_response = "Welcome"
    mock_false_response = "SQL Error: Conversion failed"
    
    with patch('aiohttp.ClientSession') as mock_session:
        mock_session.return_value.__aenter__.return_value.get.return_value.__aenter__.side_effect = [
            MagicMock(status=200, text=MagicMock(return_value=mock_true_response)),
            MagicMock(status=200, text=MagicMock(return_value=mock_false_response))
        ]
        
        # Test payload'ı
        payload = next(p for p in PayloadGenerator.get_blind_payloads() if "CASE" in p.value)
        
        # Testi çalıştır
        result = await scanner.test_blind_injection(payload)
        
        # Sonuçları kontrol et
        assert result is not None
        assert result.vulnerability_type == "Blind SQL Injection (Error-based)"
        assert result.url == TEST_URL
        assert result.parameter == TEST_PARAMETER
        assert result.severity == "High"

@pytest.mark.asyncio
async def test_blind_time_injection(scanner, mock_response):
    """Time-based blind SQL injection testini test eder."""
    # Mock response ayarları
    with patch('aiohttp.ClientSession') as mock_session, \
         patch('time.time') as mock_time:
        
        # İlk istek için zaman
        mock_time.side_effect = [1.0, 2.0, 3.0, 9.0]  # 6 saniyelik fark
        
        mock_session.return_value.__aenter__.return_value.get.return_value.__aenter__.side_effect = [
            MagicMock(status=200, text=MagicMock(return_value="response1")),
            MagicMock(status=200, text=MagicMock(return_value="response2"))
        ]
        
        # Test payload'ı
        payload = next(p for p in PayloadGenerator.get_blind_payloads() if "sleep" in p.value.lower())
        
        # Testi çalıştır
        result = await scanner.test_blind_injection(payload)
        
        # Sonuçları kontrol et
        assert result is not None
        assert result.vulnerability_type == "Blind SQL Injection (Time-based)"
        assert result.url == TEST_URL
        assert result.parameter == TEST_PARAMETER
        assert result.severity == "High"

@pytest.mark.asyncio
async def test_blind_content_injection(scanner, mock_response):
    """Content-based blind SQL injection testini test eder."""
    # Mock response ayarları
    mock_true_response = "A" * 1000  # Uzun yanıt
    mock_false_response = "B" * 100   # Kısa yanıt
    
    with patch('aiohttp.ClientSession') as mock_session:
        mock_session.return_value.__aenter__.return_value.get.return_value.__aenter__.side_effect = [
            MagicMock(status=200, text=MagicMock(return_value=mock_true_response)),
            MagicMock(status=200, text=MagicMock(return_value=mock_false_response))
        ]
        
        # Test payload'ı
        payload = next(p for p in PayloadGenerator.get_blind_payloads() if "CASE" in p.value)
        
        # Testi çalıştır
        result = await scanner.test_blind_injection(payload)
        
        # Sonuçları kontrol et
        assert result is not None
        assert result.vulnerability_type == "Blind SQL Injection (Content-based)"
        assert result.url == TEST_URL
        assert result.parameter == TEST_PARAMETER
        assert result.severity == "High"

@pytest.mark.asyncio
async def test_scan_parameter(scanner):
    """Parametre tarama fonksiyonunu test eder."""
    with patch.object(scanner, 'test_blind_injection') as mock_test:
        # Mock sonuç ayarla
        mock_result = ScanResult(
            vulnerability_type="Blind SQL Injection (Boolean-based)",
            url=TEST_URL,
            parameter=TEST_PARAMETER,
            payload="test payload",
            details="test details",
            severity="High"
        )
        mock_test.return_value = mock_result
        
        # Taramayı çalıştır
        results = await scanner.scan_parameter()
        
        # Sonuçları kontrol et
        assert len(results) > 0
        assert isinstance(results[0], ScanResult)
        assert results[0].vulnerability_type.startswith("Blind SQL Injection")

@pytest.mark.asyncio
async def test_scan_url(scanner):
    """URL tarama fonksiyonunu test eder."""
    with patch.object(scanner, 'scan_parameter') as mock_scan:
        # Mock sonuç ayarla
        mock_scan.return_value = [
            ScanResult(
                vulnerability_type="Blind SQL Injection (Boolean-based)",
                url=TEST_URL,
                parameter=TEST_PARAMETER,
                payload="test payload",
                details="test details",
                severity="High"
            )
        ]
        
        # Taramayı çalıştır
        results = await scanner.scan_url()
        
        # Sonuçları kontrol et
        assert TEST_PARAMETER in results
        assert len(results[TEST_PARAMETER]) > 0
        assert results[TEST_PARAMETER][0].vulnerability_type.startswith("Blind SQL Injection")

@pytest.mark.asyncio
async def test_proxy_support(scanner, mock_response):
    """Proxy desteğini test eder."""
    proxy_url = "http://127.0.0.1:8080"
    scanner_with_proxy = SQLInjectionScanner(TEST_URL, None, proxy_url)
    
    with patch('aiohttp.ClientSession.get') as mock_get:
        mock_get.return_value.__aenter__.return_value = mock_response
        mock_response.status = 200
        mock_response.text = Mock(return_value="test response")
        
        async with scanner_with_proxy:
            # Test isteği gönder
            status, response_text, headers = await scanner_with_proxy._make_request(
                TEST_URL,
                {"test": "value"}
            )
            
            # Proxy kullanıldığını doğrula
            mock_get.assert_called_with(
                TEST_URL,
                params={"test": "value"},
                proxy={"http": proxy_url, "https": proxy_url}
            )
            
            assert status == 200
            assert response_text == "test response"

@pytest.mark.asyncio
async def test_proxy_error_handling(scanner):
    """Proxy hata yönetimini test eder."""
    invalid_proxy = "http://invalid.proxy:8080"
    scanner_with_invalid_proxy = SQLInjectionScanner(TEST_URL, None, invalid_proxy)
    
    async with scanner_with_invalid_proxy:
        # Geçersiz proxy ile istek gönder
        status, response_text, headers = await scanner_with_invalid_proxy._make_request(
            TEST_URL,
            {"test": "value"}
        )
        
        # Hata durumunu kontrol et
        assert status == 0
        assert "İstek hatası" in response_text 